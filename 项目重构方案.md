# Tushare MCP Server - 项目重构方案

## 📋 当前问题分析

### 当前代码结构问题

1. **单一文件过大**：`server.py` 包含所有功能（969行）
2. **职责不清**：配置、缓存、工具、格式化等混在一起
3. **难以扩展**：新增MCP工具需要修改主文件
4. **测试困难**：功能耦合，难以单独测试

### 代码模块分析

当前 `server.py` 包含以下模块：

1. **配置管理**：环境变量、Token管理
2. **缓存管理**：SQLite缓存系统
3. **MCP工具**：股票查询、搜索、财务报表
4. **数据格式化**：财务报表分析格式化
5. **MCP服务器**：FastMCP实例和启动逻辑

## 🏗️ 新目录结构设计

```
tushare_MCP/
├── server.py                 # 主入口文件（简化）
├── config/                   # 配置模块
│   ├── __init__.py
│   ├── settings.py          # 配置常量
│   └── token_manager.py     # Token管理
├── cache/                    # 缓存模块
│   ├── __init__.py
│   └── cache_manager.py     # SQLite缓存管理器
├── tools/                    # MCP工具模块
│   ├── __init__.py
│   ├── base.py              # 基础工具类
│   ├── stock_tools.py       # 股票相关工具
│   ├── financial_tools.py   # 财务报表工具
│   └── cache_tools.py       # 缓存管理工具
├── formatters/               # 数据格式化模块
│   ├── __init__.py
│   └── financial_formatter.py  # 财务报表格式化
├── prompts/                  # 提示模板模块
│   ├── __init__.py
│   └── prompts.py           # 所有提示模板
└── utils/                    # 工具函数
    ├── __init__.py
    └── helpers.py           # 辅助函数
```

## 📦 模块拆分方案

### 1. config/ 配置模块

#### config/settings.py
```python
"""项目配置常量"""
from pathlib import Path

# 环境变量文件路径
LOCAL_ENV_FILE = Path(__file__).parent.parent / ".env"
USER_ENV_FILE = Path.home() / ".tushare_mcp" / ".env"

# 缓存配置
CACHE_DIR = Path(__file__).parent.parent / ".cache"
CACHE_DB = CACHE_DIR / "cache.db"

# 缓存过期时间（秒）
CACHE_TTL = {
    'stock_basic': 24 * 3600,
    'stock_search': 12 * 3600,
    'income_statement': 7 * 24 * 3600,
}
```

#### config/token_manager.py
```python
"""Token管理模块"""
from config.settings import LOCAL_ENV_FILE, USER_ENV_FILE
# ... Token相关函数
```

### 2. cache/ 缓存模块

#### cache/cache_manager.py
```python
"""SQLite缓存管理器"""
from config.settings import CACHE_DB, CACHE_TTL
# ... CacheManager类
```

### 3. tools/ MCP工具模块

#### tools/base.py
```python
"""基础工具类，提供通用功能"""
from mcp.server.fastmcp import FastMCP
from cache.cache_manager import cache_manager
from config.token_manager import get_tushare_token

class BaseTool:
    """MCP工具基类"""
    def __init__(self, mcp: FastMCP):
        self.mcp = mcp
        self.cache_manager = cache_manager
    
    def check_token(self) -> Optional[str]:
        """检查Token"""
        token = get_tushare_token()
        if not token:
            return "请先配置Tushare token"
        return None
```

#### tools/stock_tools.py
```python
"""股票相关MCP工具"""
from tools.base import BaseTool

class StockTools(BaseTool):
    """股票工具类"""
    
    def register_tools(self):
        """注册所有股票相关工具"""
        self.mcp.tool()(self.get_stock_basic_info)
        self.mcp.tool()(self.search_stocks)
    
    def get_stock_basic_info(self, ts_code: str = "", name: str = "") -> str:
        """获取股票基本信息"""
        # ... 实现
```

#### tools/financial_tools.py
```python
"""财务报表相关MCP工具"""
from tools.base import BaseTool
from formatters.financial_formatter import format_income_statement_analysis

class FinancialTools(BaseTool):
    """财务报表工具类"""
    
    def register_tools(self):
        """注册所有财务报表相关工具"""
        self.mcp.tool()(self.get_income_statement)
```

#### tools/cache_tools.py
```python
"""缓存管理MCP工具"""
from tools.base import BaseTool

class CacheTools(BaseTool):
    """缓存管理工具类"""
    
    def register_tools(self):
        """注册所有缓存管理工具"""
        self.mcp.tool()(self.clear_cache)
        self.mcp.tool()(self.cleanup_expired_cache)
        self.mcp.tool()(self.cleanup_duplicate_cache)
        self.mcp.tool()(self.get_cache_stats)
```

### 4. formatters/ 格式化模块

#### formatters/financial_formatter.py
```python
"""财务报表格式化"""
def format_income_statement_analysis(df: pd.DataFrame) -> str:
    """格式化利润表分析输出"""
    # ... 实现
```

### 5. prompts/ 提示模板模块

#### prompts/prompts.py
```python
"""MCP提示模板"""
def configure_token_prompt() -> str:
    """配置Token提示模板"""
    return """..."""

def income_statement_query_prompt() -> str:
    """利润表查询提示模板"""
    return """..."""
```

### 6. tools/__init__.py 自动发现机制

#### tools/__init__.py
```python
"""工具模块自动发现和注册"""
import sys
import importlib
import pkgutil
from pathlib import Path
from typing import List
from mcp.server.fastmcp import FastMCP
from tools.base import BaseTool

def discover_tools(mcp: FastMCP) -> List[BaseTool]:
    """
    自动发现并注册所有工具类
    
    扫描tools目录下所有模块，自动发现继承自BaseTool的类并注册
    
    工作原理：
    1. 遍历tools目录下的所有Python模块
    2. 动态导入每个模块
    3. 查找所有继承自BaseTool的类
    4. 自动实例化并调用register_tools()方法
    5. 工具自动注册到MCP服务器
    
    使用示例：
        from tools import discover_tools
        discover_tools(mcp)  # 自动发现并注册所有工具
    """
    tools = []
    tools_dir = Path(__file__).parent
    
    print("开始自动发现MCP工具...", file=sys.stderr)
    
    # 遍历tools目录下的所有Python文件
    for module_info in pkgutil.iter_modules([str(tools_dir)]):
        module_name = module_info.name
        
        # 跳过特殊文件
        if module_name in ['__init__', 'base']:
            continue
        
        try:
            # 动态导入模块
            module = importlib.import_module(f'tools.{module_name}')
            
            # 查找所有继承自BaseTool的类
            for attr_name in dir(module):
                attr = getattr(module, attr_name)
                
                # 检查是否是BaseTool的子类且不是BaseTool本身
                if (isinstance(attr, type) and 
                    issubclass(attr, BaseTool) and 
                    attr != BaseTool):
                    
                    try:
                        # 实例化并注册工具
                        tool_instance = attr(mcp)
                        tool_instance.register_tools()
                        tools.append(tool_instance)
                        print(f"✓ 已自动注册工具: {attr_name} (来自 {module_name})", file=sys.stderr)
                    except Exception as e:
                        print(f"✗ 注册工具 {attr_name} 时出错: {str(e)}", file=sys.stderr)
        
        except ImportError as e:
            print(f"✗ 导入模块 {module_name} 失败: {str(e)}", file=sys.stderr)
        except Exception as e:
            print(f"✗ 加载工具模块 {module_name} 时出错: {str(e)}", file=sys.stderr)
    
    print(f"工具发现完成，共注册 {len(tools)} 个工具类", file=sys.stderr)
    return tools
```

### 7. server.py 主入口（简化，自动发现）

```python
"""MCP服务器主入口"""
import sys
from mcp.server.fastmcp import FastMCP
from config.settings import LOCAL_ENV_FILE
from config.token_manager import get_tushare_token, init_env_file
from cache.cache_manager import cache_manager
from tools import discover_tools  # 自动发现工具
from prompts.prompts import configure_token_prompt, income_statement_query_prompt
import tushare as ts

# 创建MCP服务器实例
mcp = FastMCP("Tushare Stock Info")

# 注册提示模板
@mcp.prompt()
def configure_token() -> str:
    """配置Tushare token的提示模板"""
    return configure_token_prompt()

@mcp.prompt()
def income_statement_query() -> str:
    """利润表查询提示模板"""
    return income_statement_query_prompt()

# 自动发现并注册所有工具（零配置）
discover_tools(mcp)

if __name__ == "__main__":
    # 初始化
    init_env_file()
    
    # 加载Token
    token = get_tushare_token()
    if token:
        try:
            ts.set_token(token)
            env_source = "项目本地 .env" if LOCAL_ENV_FILE.exists() else "用户目录 .env"
            print(f"已从 {env_source} 加载 Tushare token", file=sys.stderr)
        except Exception as e:
            print(f"加载 token 时出错: {str(e)}", file=sys.stderr)
    
    # 启动时清理
    try:
        expired_count = cache_manager.cleanup_expired()
        if expired_count > 0:
            print(f"已标记 {expired_count} 条过期缓存记录", file=sys.stderr)
    except Exception as e:
        print(f"标记过期缓存时出错: {str(e)}", file=sys.stderr)
    
    mcp.run()
```

## 🎯 扩展性设计（自动发现）

### 新增MCP工具的步骤（零配置）

#### 示例：添加市场数据工具

1. **创建工具文件** `tools/market_tools.py`
```python
"""市场数据相关MCP工具"""
from tools.base import BaseTool

class MarketTools(BaseTool):
    """市场数据工具类"""
    
    def register_tools(self):
        """注册所有市场数据相关工具"""
        self.mcp.tool()(self.get_market_data)
        self.mcp.tool()(self.get_market_index)
    
    def get_market_data(self, date: str = "") -> str:
        """
        获取市场数据
        
        参数:
            date: 日期（YYYYMMDD格式）
        """
        error = self.check_token()
        if error:
            return error
        
        # 实现工具逻辑
        # ...
        return "市场数据..."
    
    def get_market_index(self, index_code: str = "") -> str:
        """获取市场指数"""
        error = self.check_token()
        if error:
            return error
        
        # 实现工具逻辑
        # ...
        return "指数数据..."
```

2. **完成！** 无需任何其他操作，工具会自动被发现和注册

**自动发现流程：**
```
启动 server.py
    ↓
调用 discover_tools(mcp)
    ↓
扫描 tools/ 目录
    ↓
发现 market_tools.py
    ↓
导入模块，找到 MarketTools 类
    ↓
检查是否继承自 BaseTool ✓
    ↓
实例化 MarketTools(mcp)
    ↓
调用 register_tools()
    ↓
工具自动注册到MCP服务器 ✓
```

**优势：**
- ✅ **零配置**：无需修改server.py
- ✅ **自动发现**：新增文件自动识别
- ✅ **错误隔离**：单个工具出错不影响其他工具
- ✅ **易于调试**：启动时显示注册日志

### 优势

1. ✅ **模块化**：功能清晰分离
2. ✅ **零配置扩展**：新增工具只需添加文件，自动发现
3. ✅ **易测试**：每个模块可独立测试
4. ✅ **易维护**：代码组织清晰
5. ✅ **可复用**：基础类可被多个工具复用
6. ✅ **自动化**：无需手动注册，减少出错

## 📋 重构步骤

1. ✅ 创建新目录结构
2. ✅ 拆分配置模块
3. ✅ 拆分缓存模块
4. ✅ 拆分工具模块
5. ✅ 拆分格式化模块
6. ✅ 拆分提示模板
7. ✅ 简化server.py
8. ✅ 更新导入路径
9. ✅ 测试功能完整性

## ❓ 待确认问题

1. **目录结构**：是否同意此目录结构？✅
2. **工具注册方式**：✅ 已确认使用自动发现机制
3. **向后兼容**：是否需要保持API兼容性？
4. **工具命名规范**：工具类是否需要特定命名规范（如必须以Tools结尾）？

---

**请确认此重构方案，确认后我将开始实施。**

